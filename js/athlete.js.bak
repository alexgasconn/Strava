// Backup of js/athlete.js
// Created automatically before refactor

// Original content follows:

// js/athlete.js - Updated: 2026-02-23 to fix runs reference error
import * as utils from './utils.js';

let currentDataType = 'time';

export function renderAthleteTab(allActivities, dateFilterFrom, dateFilterTo, sportFilter = 'all', dataType = 'time') {
    currentDataType = dataType;
    console.log("ðŸŽ½ renderAthleteTab: Initializing Athlete Tab with sportFilter:", sportFilter);

    // Add filters UI
    addAthleteFilters();

    // Filter activities
    const filteredActivities = filterActivities(allActivities, dateFilterFrom, dateFilterTo, sportFilter);
    console.log("ðŸŽ½ renderAthleteTab: Filtered activities:", filteredActivities.length);

    // For stats, use the filtered activities, but for runs-specific stats, filter to runs
    const runs = filteredActivities.filter(a => a.type && a.type.includes('Run'));
    console.log("ðŸŽ½ renderAthleteTab: Runs in filtered activities:", runs.length);

    const athleteData = JSON.parse(localStorage.getItem('strava_athlete_data'));
    const zonesData = JSON.parse(localStorage.getItem('strava_training_zones'));

    // Renderizar componentes
    if (athleteData) renderAthleteProfile(athleteData);
    if (zonesData) renderTrainingZones(zonesData);

    renderAllTimeStats(filteredActivities); // Use filtered activities for general stats
    renderRecordStats(runs); // Keep runs for record stats
    renderStartTimeHistogram(filteredActivities, dataType);
    renderYearlyComparison(filteredActivities, dataType);
    renderWeeklyMixChart(filteredActivities, dataType);
    renderMonthlyMixChart(filteredActivities, dataType);
    renderHourMatrix(filteredActivities, dataType);
    renderYearMonthMatrix(filteredActivities, dataType);
    renderMonthWeekdayMatrix(filteredActivities, dataType);
    renderMonthDayMatrix(filteredActivities, dataType);
    renderMonthHourMatrix(filteredActivities, dataType);
    renderYearHourMatrix(filteredActivities, dataType);
    renderYearWeekdayMatrix(filteredActivities, dataType);
    renderInteractiveMatrix(filteredActivities, dataType);

    console.log("ðŸŽ½ renderAthleteTab: Athlete tab rendered");
}
function renderAllTimeStats(activities) {
    const container = document.getElementById('all-time-stats-cards');
    if (!container) return;
    const totalDist = (activities.reduce((s, a) => s + a.distance, 0) / 1000).toFixed(0);
    const totalTime = (activities.reduce((s, a) => s + a.moving_time, 0) / 3600).toFixed(1);
    const totalElev = activities.reduce((s, a) => s + a.total_elevation_gain, 0).toLocaleString();
    container.innerHTML = `
        <div class="card"><h3>Total Activities</h3><p>${activities.length}</p></div>
        <div class="card"><h3>Total Distance</h3><p>${totalDist} km</p></div>
        <div class="card"><h3>Total Time</h3><p>${totalTime} h</p></div>
        <div class="card"><h3>Total Elevation</h3><p>${totalElev} m</p></div>
    `;
}

function renderRecordStats(runs) {
    const container = document.getElementById('record-stats');
    if (!container || runs.length === 0) return;

    const longestRun = [...runs].sort((a, b) => b.distance - a.distance)[0];

    const fastestRun = [...runs].filter(r => r.distance > 1000).sort((a, b) => a.average_speed - b.average_speed).reverse()[0];
    const paceMin = fastestRun.average_speed > 0 ? (1000 / fastestRun.average_speed) / 60 : 0;
    const paceStr = paceMin > 0 ? `${Math.floor(paceMin)}:${Math.round((paceMin % 1) * 60).toString().padStart(2, '0')}` : '-';

    const mostElev = [...runs].sort((a, b) => b.total_elevation_gain - a.total_elevation_gain)[0];

    const oldestRun = [...runs].sort((a, b) => new Date(a.start_date_local) - new Date(b.start_date_local))[0];
    const newestRun = [...runs].sort((a, b) => new Date(b.start_date_local) - new Date(a.start_date_local))[0];
    const timeDiffMs = new Date(newestRun.start_date_local) - new Date(oldestRun.start_date_local);
    const timeDiffDays = Math.floor(timeDiffMs / (1000 * 60 * 60 * 24));

    const hourCounts = Array(24).fill(0);
    runs.forEach(run => {
        let hour = new Date(run.start_date_local).getHours();
        hour = (hour - 2 + 24) % 24;
        hourCounts[hour]++;
    });
    const favHour = hourCounts.indexOf(Math.max(...hourCounts));

    const dayCounts = Array(7).fill(0);
    runs.forEach(run => {
        const date = new Date(run.start_date_local);
        // getDay(): 0=Sunday, 1=Monday, ..., 6=Saturday
        let dayIdx = date.getDay();
        // Shift so Monday=0, Sunday=6
        dayIdx = (dayIdx + 6) % 7;
        dayCounts[dayIdx]++;
    });
    const favDayIdx = dayCounts.indexOf(Math.max(...dayCounts));
    const dayLabels = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    const favDay = dayLabels[favDayIdx];

    // Average distance
    const avgDist = runs.length ? (runs.reduce((s, a) => s + a.distance, 0) / runs.length / 1000).toFixed(2) : 0;

    // Average pace
    const avgPaceMin = runs.length
        ? (runs.reduce((s, r) => s + (r.average_speed > 0 ? (1000 / r.average_speed) / 60 : 0), 0) / runs.length)
        : 0;
    const avgPaceStr = avgPaceMin > 0
        ? `${Math.floor(avgPaceMin)}:${Math.round((avgPaceMin % 1) * 60).toString().padStart(2, '0')}`
        : '-';

    // Solo vs Group workouts
    const soloCount = runs.filter(r => Number(r.athlete_count) === 1).length;
    const groupCount = runs.length - soloCount;
    const soloPct = runs.length ? ((soloCount / runs.length) * 100).toFixed(1) : 0;
    const groupPct = runs.length ? ((groupCount / runs.length) * 100).toFixed(1) : 0;

    container.innerHTML = `
            <ul style="list-style: none; padding-left: 0; line-height: 1.8;">
                <li><strong>Longest Run:</strong> ${(longestRun.distance / 1000).toFixed(2)} km (<a href="html/activity.html?id=${longestRun.id}" target="_blank">View</a>)</li>
                <li><strong>Fastest Run (Pace):</strong> ${paceStr} /km over ${(fastestRun.distance / 1000).toFixed(1)}k (<a href="html/activity.html?id=${fastestRun.id}" target="_blank">View</a>)</li>
                <li><strong>Most Elevation:</strong> ${Math.round(mostElev.total_elevation_gain)} m (<a href="html/activity.html?id=${mostElev.id}" target="_blank">View</a>)</li>
                <li><strong>Time Span:</strong> ${timeDiffDays} days (${oldestRun.start_date_local.substring(0, 10)} to ${newestRun.start_date_local.substring(0, 10)})</li>
                <li><strong>Favourite Hour:</strong> ${favHour}:00</li>
                <li><strong>Favourite Day:</strong> ${favDay}</li>
                <li><strong>Average Distance:</strong> ${avgDist} km</li>
                <li><strong>Average Pace:</strong> ${avgPaceStr} /km</li>
                <li><strong>Solo Workouts:</strong> ${soloCount} (${soloPct}%)</li>
                <li><strong>Group Workouts:</strong> ${groupCount} (${groupPct}%)</li>
            </ul>
        `;
}

function renderStartTimeHistogram(runs, dataType = 'count') {
    const values = Array(24).fill(0);
    runs.forEach(run => {
        let hour = new Date(run.start_date_local).getHours();
        hour = (hour - 2 + 24) % 24;
        switch (dataType) {
            case 'count':
                values[hour]++;
                break;
            case 'time':
                values[hour] += run.moving_time / 3600;
                break;
            case 'distance':
                values[hour] += run.distance / 1000;
                break;
        }
    });
    const labels = values.map((_, i) => `${i}:00`);
    const labelMap = {
        count: '# of Activities',
        time: 'Time (hours)',
        distance: 'Distance (km)'
    };
    createUiChart('start-time-histogram', {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: labelMap[dataType],
                data: values,
                backgroundColor: 'rgba(252, 82, 0, 0.7)'
            }]
        },
        options: {
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, title: { display: true, text: labelMap[dataType] } } }
        }
    });
}

// ... backup contains full original content ...
